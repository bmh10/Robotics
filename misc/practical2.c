//#pragma config(Sensor, S1,  , sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define TURN_SPEED 20
#define FORWARD_SPEED 25
#define TURN_CONST 13100
#define FORWARD_CONST 2095
#define PI 3.141592
#define DISPLAY_SCALE 0.0625
#define TIME_SPLIT 1
#define TEST 0

// screen size = (100 x 64)

float x = 25*DISPLAY_SCALE, y = 60*DISPLAY_SCALE, angle = 0;

void Draw()
{
  nxtSetPixel((int)(x/DISPLAY_SCALE), (int)(y/DISPLAY_SCALE));
}

void Wait()
{
  wait1Msec(TIME_SPLIT);
}

void Forward(float distance)
{
  nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
  nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;

  motor[motorC] = FORWARD_SPEED;
  motor[motorB] = FORWARD_SPEED;

  float timeLeft = distance*FORWARD_CONST/(float)FORWARD_SPEED;
  for (; timeLeft > TIME_SPLIT; timeLeft -= TIME_SPLIT)
  {
    Wait();
    x+=cos(angle)/1000;
    y+=sin(angle)/1000;

    Draw();
  }

  motor[motorC] = 0;
  motor[motorB] = 0;
}

void Forward40cm()
{
  Forward(40);
}

void Backward(float distance)
{
  nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
  nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;

  motor[motorC] = -FORWARD_SPEED;
  motor[motorB] = -FORWARD_SPEED;

  float timeLeft = distance*FORWARD_CONST/(float)FORWARD_SPEED;
  for (; timeLeft > TIME_SPLIT; timeLeft -= TIME_SPLIT)
  {
    Wait();
    x-=cos(angle)/1000;
    y-=sin(angle)/1000;

    Draw();
  }

  motor[motorC] = 0;
  motor[motorB] = 0;
}

void Backward40cm()
{
  Backward(40);
}

void Anticlockwise(float a)
{
  nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
  nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;

  motor[motorC] = -TURN_SPEED;
  motor[motorB] = TURN_SPEED;

  float timeLeft = a*(float)TURN_CONST/(float)TURN_SPEED;
  for (; timeLeft > TIME_SPLIT; timeLeft -= TIME_SPLIT)
  {
    Wait();
  }
  wait1Msec(timeLeft);
  angle += a;

  motor[motorC] = 0;
  motor[motorB] = 0;
}


void Clockwise(float a)
{
  nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
  nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;

  motor[motorC] = TURN_SPEED;
  motor[motorB] = -TURN_SPEED;

  float timeLeft = a*(float)TURN_CONST/(float)TURN_SPEED;
  for (; timeLeft > TIME_SPLIT; timeLeft -= TIME_SPLIT)
  {
    Wait();
  }
  wait1Msec(timeLeft);
  angle -= a;

  motor[motorC] = 0;
  motor[motorB] = 0;
}


void Left90deg()
{
  Anticlockwise(PI/2.0);
}


void Right90deg()
{
  Clockwise(PI/2.0);
}


void test()
{
  Forward40cm();
  wait1Msec(1000);
  Backward40cm();
  wait1Msec(1000);
  Left90deg();
  wait1Msec(1000);
  Right90deg();
}

void drawSquare()
{
  int i = 0;
  while( i < 4 )
  {
    Forward40cm();
    Right90deg();
    i++;
  }
}

task main()
{
  //SensorType[S1] = sensorLightActive;
  if (TEST)
  {
     test();
  }
  else
  {
     drawSquare();
  }
  wait1Msec(10000);
}
