//#pragma config(Sensor, S1,  , sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define TURN_SPEED 20
#define FORWARD_SPEED 25
#define TURN_CONST 13100
#define FORWARD_CONST 2095
#define PI 3.141592
#define DISPLAY_SCALE 0.0625
#define TIME_SPLIT 1
#define NUM_PARTICLES 100
#define PATH_FOLLOWING 1

#include "sample.h"

/*
struct Particle {
  float x;
  float y;
  float theta;
  float weight;
};
*/

float particles[NUM_PARTICLES][4]; //x, y, theta, weight

// screen size = (100 x 64)

float x = 25*DISPLAY_SCALE, y = 60*DISPLAY_SCALE, angle = 0;

void Draw()
{
  nxtSetPixel((int)(x/DISPLAY_SCALE), (int)(y/DISPLAY_SCALE));

  for (int i=0; i < NUM_PARTICLES; i++)
  {
    nxtSetPixel((int)(particles[i][0]/DISPLAY_SCALE), (int)(particles[i][1]/DISPLAY_SCALE));
  }
}

void Wait()
{
  wait1Msec(TIME_SPLIT);
}

void updateParticlesForward()
{
  float e, f;
  float D = 1/1000;

  for (int i=0; i < NUM_PARTICLES; i++)
  {
    e = sampleGaussian(0.0, 1.0);
    f = sampleGaussian(0.0, 1.0);
    particles[i][0] += (D+e)*cos(angle);
    particles[i][1] += (D+e)*sin(angle);
    particles[i][2] += f;
  }
}

void updateParticlesRotate(float a)
{
  float g;

  for (int i=0; i < NUM_PARTICLES; i++)
  {
    g = sampleGaussian(0.0, 1.0);
    particles[i][2] += (a + g);
  }
}

void Forward(float distance)
{
  nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
  nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;

  motor[motorC] = FORWARD_SPEED;
  motor[motorB] = FORWARD_SPEED;

  float timeLeft = distance*FORWARD_CONST/(float)FORWARD_SPEED;
  for (; timeLeft > TIME_SPLIT; timeLeft -= TIME_SPLIT)
  {
    Wait();
    x+=cos(angle)/1000;
    y+=sin(angle)/1000;
    updateParticlesForward();

    Draw();
  }

  motor[motorC] = 0;
  motor[motorB] = 0;
}

void Forward40cm()
{
  Forward(40);
}

void Backward(float distance)
{
  nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
  nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;

  motor[motorC] = -FORWARD_SPEED;
  motor[motorB] = -FORWARD_SPEED;

  float timeLeft = distance*FORWARD_CONST/(float)FORWARD_SPEED;
  for (; timeLeft > TIME_SPLIT; timeLeft -= TIME_SPLIT)
  {
    Wait();
    x-=cos(angle)/1000;
    y-=sin(angle)/1000;

    Draw();
  }

  motor[motorC] = 0;
  motor[motorB] = 0;
}

void Backward40cm()
{
  Backward(40);
}

void Anticlockwise(float a)
{
  nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
  nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;

  motor[motorC] = -TURN_SPEED;
  motor[motorB] = TURN_SPEED;

  float timeLeft = a*(float)TURN_CONST/(float)TURN_SPEED;
  for (; timeLeft > TIME_SPLIT; timeLeft -= TIME_SPLIT)
  {
    Wait();
  }
  wait1Msec(timeLeft);
  angle += a;

  motor[motorC] = 0;
  motor[motorB] = 0;
}


void Clockwise(float a)
{
  nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
  nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;

  motor[motorC] = TURN_SPEED;
  motor[motorB] = -TURN_SPEED;

  float timeLeft = a*(float)TURN_CONST/(float)TURN_SPEED;
  for (; timeLeft > TIME_SPLIT; timeLeft -= TIME_SPLIT)
  {
    Wait();
  }
  wait1Msec(timeLeft);
  angle -= a;
  updateParticlesRotate(a);

  motor[motorC] = 0;
  motor[motorB] = 0;
}

void Left90deg()
{
  Anticlockwise(PI/2.0);
}

void Right90deg()
{
  Clockwise(PI/2.0);
}

void drawSquare()
{
  int i = 0;
  while( i < 4 )
  {
    Forward40cm();
    Right90deg();
    i++;
  }
}

void initParticles()
{
  for (int i=0; i < NUM_PARTICLES; i++)
  {
    particles[i][0] = 0;
    particles[i][1] = 0;
    particles[i][2] = 0;
    particles[i][3] = 1/NUM_PARTICLES;
  }
}



void navigateToWaypoint(float wx, float wy)
{
  float mx, my, mt, dx, dy, ang, dist;

  for (int i=0; i < NUM_PARTICLES; i++)
  {
    mx += particles[i][3]*particles[i][0];
    my += particles[i][3]*particles[i][1];
    mt += particles[i][3]*particles[i][2];   
  }

  dx = wx-mx;
  dy = wy-my;
  ang = atan(dy/dx) - mt;

  //Ensure -PI < ang <= PI
  while (ang < -PI)
  {
    ang += 2*PI;
  }
  while (angle > PI)
  {
    ang -= 2*PI;
  }
  
  Clockwise(ang); //possibly anitclockwise
  
  dist = sqrt(dx*dx + dy*dy);
  Forward(dist);
  
  wait1Msec(1000);
}

void runPathTest()
{
  navigateToWaypoint(0.5, 0.5 );
  navigateToWaypoint(0.5, -0.2);
  navigateToWaypoint(0  , 0   );
}

task main()
{ 
  initParticles();
  if (PATH_FOLLOWING)
    runPathTest();
  else
    drawSquare();
  wait1Msec(10000);
}