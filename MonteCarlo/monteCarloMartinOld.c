#pragma config(Sensor, S4,     sonarSensor,         sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define X 0
#define Y 1
#define ANGLE 2
#define WEIGHT 3

#define TURN_SPEED 20
#define FORWARD_SPEED 25
#define TURN_CONST 23000
#define FORWARD_CONST 2200
#define PI 3.14159265358979
#define DISPLAY_SCALE 1.20
#define TIME_SPLIT 1
#define NUM_PARTICLES 10
#define DRAW_DIST 10

#define K 0.005
#define MAX_ANGLE 20

const int NUMBER_OF_WALLS = 8;

#include "sample.h"

void navigateToWaypoint(float wx, float wy);

//                                 a    b    c    d    e    f    g    h
float wallAx[NUMBER_OF_WALLS] = {  0,   0,  84,  84, 168, 168, 210, 210};
float wallAy[NUMBER_OF_WALLS] = {  0, 168, 126, 210, 210,  84,  84,   0};
float wallBx[NUMBER_OF_WALLS] = {  0,  84,  84, 168, 168, 210, 210,   0};
float wallBy[NUMBER_OF_WALLS] = {168, 168, 210, 210,  84,  84,   0,   0};

float waypoints[NUMBER_OF_WALLS][2] = {{180,30},{180,54},{126,54},{126,168},{126,126},{30,54},{84,54},{84,30}};

float particles[NUM_PARTICLES][4]; // x, y, theta, weight

// screen size = (100 x 64)

// Robot's pose
float robotx = 84, roboty = 30, robotangle = 0;

//float yoff = -64*DISPLAY_SCALE, xoff = 0*DISPLAY_SCALE;


void calculateMeanPosition()
{
  float mx = 0, my = 0, mt = 0;

  for (int i = 0; i < NUM_PARTICLES; i++)
  {
    mx += particles[i][X]*particles[i][WEIGHT];
    my += particles[i][Y]*particles[i][WEIGHT];
    mt += particles[i][ANGLE]*particles[i][WEIGHT];
  }

  robotx = mx;
  roboty = my;
  robotangle = mt;
}

float calculateDistanceToWall(float x, float y, float a)
{
  float top, bot, m, smallestM = 10000, xco, yco;

  for (int i = 0; i < NUMBER_OF_WALLS; i++)
  {
    top = (wallBy[i]-wallAy[i])*(wallAx[i] - particles[i][X])
          - (wallBx[i]-wallAx[i])*(wallAy[i]-particles[i][Y]);
    bot = (wallBy[i]-wallAy[i])*cos(particles[i][ANGLE])
          - (wallBx[i]-wallAx[i])*sin(particles[i][ANGLE]);
    m = top/bot;
    xco = particles[i][X] + m*cos(particles[i][ANGLE]);
    yco = particles[i][Y] + m*sin(particles[i][ANGLE]);

    if (m > 0 && m < smallestM
        && ((wallAx[i] > wallBx[i] && xco <= wallAx[i] && xco >= wallBx[i])
        || (wallAx[i] <= wallBx[i] && xco >= wallAx[i] && xco <= wallBx[i]))
        && ((wallAy[i] > wallBy[i] && yco <= wallAy[i] && yco >= wallBy[i])
        || (wallAy[i] <= wallBy[i] && yco >= wallAy[i] && yco <= wallBy[i])))
    {
      smallestM = m;
    }
  }

  return smallestM;
}



void turnParticlesTo(float a)
{
  float g, m, p;
  float z = SensorValue[sonarSensor]; //calculateDistanceToWall(robotx, roboty, robotangle);
  float var = 1.0;
  float sumWeights = 0;

  for (int i = 0; i < NUM_PARTICLES; i++)
  {
    g = 0; //sampleGaussian(0.0, 0.05);
    particles[i][ANGLE] += (a + g);
    // UPDATE WEIGHT HERE
    m = calculateDistanceToWall(particles[i][X], particles[i][Y], particles[i][ANGLE]);
    p = -pow(z-m, 2)/(2*var);
    particles[i][WEIGHT] *= exp(p) + K;
    sumWeights += particles[i][WEIGHT];
  }

  // Normalise
  for (int i = 0; i < NUM_PARTICLES; i++)
    particles[i][WEIGHT] /= sumWeights;

  // Resample
  float cumWeights[NUM_PARTICLES];
  sumWeights = 0;

  cumWeights[0] = particles[0][WEIGHT];

  for (int i = 1; i < NUM_PARTICLES; i++)
    cumWeights[i] = cumWeights[i-1] + particles[i][WEIGHT];

  float newParticles[NUM_PARTICLES][4];

  for (int i = 0; i < NUM_PARTICLES; i++)
  {
    float r = (rand() % 10000)/(float)10000;

    int index = NUM_PARTICLES-1;

    for (int j = 0; j < NUM_PARTICLES; j++)
    {
      if (r >= cumWeights[j])
      {
        index = j;
        break;
      }
    }

    newParticles[i][X] = particles[index][X];
    newParticles[i][Y] = particles[index][Y];
    newParticles[i][ANGLE] = particles[index][ANGLE];
    newParticles[i][WEIGHT] = particles[index][WEIGHT];
    sumWeights += newParticles[i][WEIGHT];
  }

  // replace them with the new ones
  for (int i=0; i < NUM_PARTICLES; i++)
  {
    for (int j=0; j < 4; j++)
    {
      particles[i][j] = newParticles[i][j];
    }
  }

  // Normalise
  for (int i = 0; i < NUM_PARTICLES; i++)
    particles[i][WEIGHT] /= sumWeights;

  calculateMeanPosition();
}

void moveParticlesForward(float dist)
{
  float e, f, m, p;
  float z =  calculateDistanceToWall(robotx, roboty, robotangle); //SensorValue[sonarSensor];
  float var = 0.80;
  float sumWeights = 0;

  for (int i = 0; i < NUM_PARTICLES; i++)
  {
    e = 0; //sampleGaussian(0.0, 0.05);
    f = 0; //sampleGaussian(0.0, 0.05);
    particles[i][X] += (dist + e) * cos(particles[i][ANGLE]);
    particles[i][Y] += (dist + e) * sin(particles[i][ANGLE]);
    particles[i][ANGLE] += f;

    // TODO: UPDATE WEIGHT HERE
    m = calculateDistanceToWall(particles[i][X], particles[i][Y], particles[i][ANGLE]);
    p = -pow(z-m, 2)/(2*var);
    particles[i][WEIGHT] *= exp(p) + K;
    sumWeights += particles[i][WEIGHT];
  }

  // Normalise
  for (int i = 0; i < NUM_PARTICLES; i++)
    particles[i][WEIGHT] /= sumWeights;

  // Resample
  float cumWeights[NUM_PARTICLES];
  sumWeights = 0;

  cumWeights[0] = particles[0][WEIGHT];

  for (int i = 1; i < NUM_PARTICLES; i++)
    cumWeights[i] = cumWeights[i-1] + particles[i][WEIGHT];

  float newParticles[NUM_PARTICLES][4];

  for (int i = 0; i < NUM_PARTICLES; i++)
  {
    float r = (rand() % 10000)/(float)10000;

    int index = NUM_PARTICLES-1;

    for (int j = 0; j < NUM_PARTICLES; j++)
    {
      if (r >= cumWeights[j])
      {
        index = j;
        break;
      }
    }

    newParticles[i][X] = particles[index][X];
    newParticles[i][Y] = particles[index][Y];
    newParticles[i][ANGLE] = particles[index][ANGLE];
    newParticles[i][WEIGHT] = particles[index][WEIGHT];
    sumWeights += newParticles[i][WEIGHT];
  }

  // replace them with the new ones
  for (int i=0; i < NUM_PARTICLES; i++)
  {
    for (int j=0; j < 4; j++)
    {
      particles[i][j] = newParticles[i][j];
    }
  }

  // Normalise
  for (int i = 0; i < NUM_PARTICLES; i++)
    particles[i][WEIGHT] /= sumWeights;

  calculateMeanPosition();
}

/*
 * +ve angles are clockwise
 */
void Turn(float a)
{
  nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
  nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
  int i = (a < 0) ? -1 : 1;
  motor[motorC] = i*TURN_SPEED;
  motor[motorB] = -i*TURN_SPEED;

  float timeLeft = i*a*(float)TURN_CONST/(float)TURN_SPEED;
  wait1Msec(timeLeft);
  turnParticlesTo(a);

  motor[motorC] = 0;
  motor[motorB] = 0;
}


void Forward(float distance)
{
  nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
  nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;

  motor[motorC] = FORWARD_SPEED;
  motor[motorB] = FORWARD_SPEED;
  int timeLeft = (int) (distance*FORWARD_CONST/(float)FORWARD_SPEED);
  wait1Msec(timeLeft);
  //DrawParticles();
  moveParticlesForward(distance);
  motor[motorC] = 0;
  motor[motorB] = 0;
}


float atan2(float dx, float dy)
{
   float phi;   //phi=radians;

   if (dx>0) {phi=atan(dy/dx);}
   else if ((dx<0)&&(dy>=0))  {phi=PI+atan(dy/dx);}
   else if ((dx<0)&&(dy<0))   {phi=-PI+atan(dy/dx);}
   else if ((dx==0)&&(dy>0))  {phi=PI/2;}
   else if ((dx==0)&&(dy<0))  {phi=-PI/2;}
   else if ((dx==0)&&(dy==0)) {phi=0;}

   return phi;
}

void navigateToWaypointAux(float wx, float wy)
{
  navigateToWaypoint(wx, wy);
}

/*
 * navigates towards (wx, wy)
 */
void navigateToWaypoint(float wx, float wy)
{
  float dx, dy, a, dist;

  dx = wx - robotx;
  dy = wy - roboty;
  a = atan2(dx, dy);

  //usleep(500000);

    Turn(a - robotangle);
    //navigateToWaypointAux(wx, wy);

    nxtDisplayStringAt(10, 30, "T%f %f", robotx, roboty);



  dist = sqrt(dx*dx + dy*dy);

  if (dist > 20)
  {
    Forward(20);
    //navigateToWaypointAux(wx, wy);
  }
  else
  {
    Forward(dist);
  }

  nxtDisplayStringAt(10, 30, "F%f %f", robotx, roboty);
}

task main()
{
  int i;
  for (i = 0; i < NUM_PARTICLES; i++)
  {
    particles[i][X] = robotx;
    particles[i][Y] = roboty;
    particles[i][ANGLE] = robotangle;
    particles[i][WEIGHT] = 1.0 / (float) NUM_PARTICLES;
  }

  for (i = 0; i < NUMBER_OF_WALLS; i++)
  {
    //i=0;
    while (robotx < waypoints[i][0]-2 || robotx > waypoints[i][0]+2
        || roboty < waypoints[i][1]-2 || roboty > waypoints[i][1]+2)
    {
      navigateToWaypoint(waypoints[i][0], waypoints[i][1]);
    }
    nxtDisplayStringAt(10, 10, "WAYPOINT %d", i);
  }

  wait1Msec(10000);
}
