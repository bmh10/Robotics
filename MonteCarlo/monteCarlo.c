#pragma config(Sensor, S4,     sonarSensor,         sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define TURN_SPEED 20
#define FORWARD_SPEED 25
#define TURN_CONST 12500
#define FORWARD_CONST 1100
#define PI 3.141592
#define DISPLAY_SCALE 1.20
#define TIME_SPLIT 1
#define NUM_PARTICLES 100
#define DRAW_DIST 10

#define K 0.03
#define MAX_ANGLE 20

const int NUMBER_OF_WALLS = 8;

#include "sample.h"

void navigateToWaypoint(int num, float wx, float wy);

/*
struct Particle {
  float x;
  float y;
  float theta;
  float weight;
};
*/
//                                 a    b    c    d    e    f    g    h
float wallAx[NUMBER_OF_WALLS] = {  0,   0,  84,  84, 168, 168, 210, 210};
float wallAy[NUMBER_OF_WALLS] = {  0, 168, 126, 210, 210,  84,  84,   0};
float wallBx[NUMBER_OF_WALLS] = {  0,  84,  84, 168, 168, 210, 210,   0};
float wallBy[NUMBER_OF_WALLS] = {168, 168, 210, 210,  84,  84,   0,   0};

float particles[NUM_PARTICLES][4]; //x, y, theta, weight

// screen size = (100 x 64)

// Robot's pose
float x = 84, y = 30, angle = 0;

float yoff = -64*DISPLAY_SCALE, xoff = 0*DISPLAY_SCALE;

/*
 * Calculates position from particles.
 * Higher weighted particles have more effect.
 */
void calculatePosition()
{
  float mx = 0, my = 0, mt = 0;

  for (int i=0; i < NUM_PARTICLES; i++)
  {
    mx += particles[i][3]*particles[i][0];
    my += particles[i][3]*particles[i][1];
    mt += particles[i][3]*particles[i][2];
  }

  //nxtDisplayStringAt(20, 40, "%f", mx);
  //nxtDisplayStringAt(20, 30, "%f", my);
  //nxtDisplayStringAt(20, 20, "%f", mt);

  x = mx;
  y = my;
  angle = mt;
}

//TASK 1 (ASSESSED FUNCTION)
float calculate_likelihood(float px, float py, float ptheta, float z)
{
  float smallestm = 1000;
  float top, bot, m, xco, yco;
  int wallIdx = -1;
  float beta;

  // Find which wall sonar beam would hit given the robot's current pose
  for (int i=0; i < NUMBER_OF_WALLS; i++)
  {
    //int i=6;
    top = (wallBy[i]-wallAy[i])*(wallAx[i] - px) - (wallBx[i]-wallAx[i])*(wallAy[i]-py);
    bot = (wallBy[i]-wallAy[i])*cos(ptheta) - (wallBx[i]-wallAx[i])*sin(ptheta);
    m = top/bot;
    xco = px + m*cos(ptheta);
    yco = py + m*sin(ptheta);

    /*
    bool a = (wallAx[i] > wallBx[i] && xco <= wallAx[i] && xco >= wallBx[i]);
    bool b = (wallAx[i] <= wallBx[i] && xco >= wallAx[i] && xco <= wallBx[i]);
    bool c = ((wallAy[i] > wallBy[i] && yco <= wallAy[i] && yco >= wallBy[i];
    bool d = (wallAy[i] <= wallBy[i] && yco >= wallAy[i] && yco <= wallBy[i]);

    nxtDisplayStringAt(10, 40, "%d, %d, %d, %d", a, b, c, d);
    */

    if (m < smallestm && m > 0
        && ((wallAx[i] > wallBx[i] && xco <= wallAx[i] && xco >= wallBx[i])
        || (wallAx[i] <= wallBx[i] && xco >= wallAx[i] && xco <= wallBx[i]))
        && ((wallAy[i] > wallBy[i] && yco <= wallAy[i] && yco >= wallBy[i])
        || (wallAy[i] <= wallBy[i] && yco >= wallAy[i] && yco <= wallBy[i])))
    {
      smallestm = m;
      wallIdx = i;
    }
  }
    //nxtDisplayStringAt(10, 50, "%f", smallestm);
    //nxtDisplayStringAt(10, 40, "%d", wallIdx);
    //nxtDisplayStringAt(10, 40, "%f, %f, %f", px, py, ptheta);

  if (wallIdx == -1)
    return 1.0;

  // Check incident angle is less than acceptable angle to get accurate sonar reading
  top = cos(ptheta)*(wallAy[wallIdx]-wallBy[wallIdx]) + sin(ptheta)*(wallBx[wallIdx]-wallAx[wallIdx]);
  bot = sqrt(pow(wallAy[wallIdx]-wallBy[wallIdx], 2) + pow(wallBx[wallIdx]-wallAx[wallIdx], 2));
  beta = acos(top/bot);

  //TODO: reconsider
  if (beta > MAX_ANGLE)
    return 1.0;

  //TODO calculate variance
  float var = 0.01;
  float f = -pow((z-smallestm),2)/(2*var);
  return (exp(f) + K);
}

void updateParticlesForward(float dist)
{
  //nxtDisplayStringAt(10, 10, "upd: %f", dist);
  float e, f, theta;
  float D = dist;
  float wsum = 0;
  int i;
  float z = SensorValue[sonarSensor];
  //nxtDisplayStringAt(20, 20, "%f", z);

  nxtDisplayStringAt(10, 50, "1");

  for (i=0; i < NUM_PARTICLES; i++)
  {
    e = sampleGaussian(0.0, 0.01);
    f = sampleGaussian(0.0, 0.005);
    theta = particles[i][2];
    particles[i][0] += (D+e)*cos(theta);
    particles[i][1] += (D+e)*sin(theta);
    particles[i][2] += f;
    // Updates weight based on likelihood function
    particles[i][3] *= calculate_likelihood(particles[i][0], particles[i][1], particles[i][2], z);
    wsum += particles[i][3];
  }

   nxtDisplayStringAt(10, 50, "2");

  // Normalise particles
  for (i=0; i < NUM_PARTICLES; i++)
  {
    particles[i][3] /= wsum;
  }
 nxtDisplayStringAt(10, 50, "3");

  // Resampling
  float cumulativeWeights[NUM_PARTICLES];
  cumulativeWeights[0] = particles[0][3];
  for (i=1; i < NUM_PARTICLES; i++)
  {
    cumulativeWeights[i] = cumulativeWeights[i-1] + particles[i][3];
  }
 nxtDisplayStringAt(10, 50, "4");
  int idx, j;
  float newparticles[NUM_PARTICLES][4]; //x, y, theta, weight
  for (i=0; i < NUM_PARTICLES; i++)
  {
    idx = rand() % NUM_PARTICLES;
    for (j=0; j < 4; j++)
      newparticles[i][j] = particles[idx][j];
  }
   nxtDisplayStringAt(10, 50, "5");

  //Copy newparticles into particles array
  for (i=0; i < NUM_PARTICLES; i++)
  {
    for (j=0; j < 4; j++)
    {
      particles[i][j] = newparticles[i][j];
    }
  }
  //particles = newparticles;
   nxtDisplayStringAt(10, 50, "6");

  calculatePosition();
   nxtDisplayStringAt(10, 50, "7");
}


void updateParticlesRotate(float a)
{
  //nxtDisplayStringAt(20, 20, "%f", a);
  float g;
  for (int i=0; i < NUM_PARTICLES; i++)
  {
    g = sampleGaussian(0.0, 0.005);
    particles[i][2] += (a + g);
    //TODO: update weight here too??
  }

  calculatePosition();
}

/*
 * Draws pixels to screen. Note screen coords are flipped so that start orientation appears same as robot's
 * start orientation.
 */
void Draw()
{
  nxtSetPixel((int)(99 - ((y+xoff)/DISPLAY_SCALE)), (int)(63 - ((x+yoff)/DISPLAY_SCALE)));
}

void DrawParticles()
{
  for (int i=0; i < NUM_PARTICLES; i++)
  {
    nxtSetPixel((int)(99 - ((particles[i][1]+xoff)/DISPLAY_SCALE)), (int)(63 - ((particles[i][0]+yoff)/DISPLAY_SCALE)));
  }
}

void Wait()
{
  wait1Msec(TIME_SPLIT);
}


void Forward(float distance)
{
  nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
  nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;

  motor[motorC] = FORWARD_SPEED;
  motor[motorB] = FORWARD_SPEED;
  int timeLeft = (int) (distance*FORWARD_CONST/(float)FORWARD_SPEED);
  //int timeToTravelEdge = timeLeft;
  //float remainingDist = distance;
  //float distPerTimeSplit = distance/timeToTravelEdge;
  //int timeFor10cms = (int) (20*FORWARD_CONST/(float)FORWARD_SPEED);
  for (; timeLeft > TIME_SPLIT; timeLeft -= TIME_SPLIT)
  {
    Wait();

    //x+=cos(angle)*distPerTimeSplit;
    //y+=sin(angle)*distPerTimeSplit;

    //if (timeLeft % timeFor20cms == 0)
    //{

      //remainingDist -= 20.0 ;
    //}

    //Draw();
  }

  updateParticlesForward(distance);
  DrawParticles();

   //if (remainingDist > 0)
   //{
    //updateParticlesForward(remainingDist);
    //DrawParticles();
   //}

  motor[motorC] = 0;
  motor[motorB] = 0;
}



/*
 * +ve angles are clockwise
 */
void Turn(float a)
{
   //nxtDisplayStringAt(20, 50, "%f", a);
  nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
  nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
  int i = (a < 0) ? -1 : 1;
  motor[motorC] = i*TURN_SPEED;
  motor[motorB] = -i*TURN_SPEED;

  float timeLeft = i*a*(float)TURN_CONST/(float)TURN_SPEED;
  for (; timeLeft > TIME_SPLIT; timeLeft -= TIME_SPLIT)
  {
    Wait();
  }
  wait1Msec(timeLeft);
  //angle += a;

  updateParticlesRotate(a);

  //nxtDisplayStringAt(20, 40, "%f", angle);

  motor[motorC] = 0;
  motor[motorB] = 0;
}

void Left90deg()
{
  Turn(-PI/2.0);
}

void Right90deg()
{
  Turn(PI/2.0);
}

void initParticles()
{
  for (int i=0; i < NUM_PARTICLES; i++)
  {
    particles[i][0] = x;
    particles[i][1] = y;
    particles[i][2] = angle;
    particles[i][3] = 1.0;///100.0; //weight set to 1/NUM_PARTICLES initially
  }
}

void navigateToWaypointAux(int num, float wx, float wy)
{
  navigateToWaypoint(num, wx, wy);
}

float atan2(float dx, float dy)
{
   float phi;   //phi=radians;

   if (dx>0) {phi=atan(dy/dx);}
   else
   if ((dx<0)&&(dy>=0))  {phi=PI+atan(dy/dx);}
   else
   if ((dx<0)&&(dy<0))   {phi=-PI+atan(dy/dx);}
   else
   if ((dx==0)&&(dy>0))  {phi=PI/2;}
   else
   if ((dx==0)&&(dy<0))  {phi=-PI/2;}
   else
   if ((dx==0)&&(dy==0)) {phi=0;}

   return phi;
}

void navigateToWaypoint(int num, float wx, float wy)
{
  float dx = 0, dy = 0, a = 0, ang = 0, dist = 0;

  nxtDisplayStringAt(10, 50, "A");

  nxtDisplayStringAt(10, 30, "%f, %f", x, y);

  dx = wx-x;
  dy = wy-y;
  a = atan2(dx, dy);
  ang = a - angle;

  nxtDisplayStringAt(10, 50, "B: %f", a);

  //nxtDisplayStringAt(20, 40, "%f", dx);
  //nxtDisplayStringAt(20, 30, "%f", ang);


  //Ensure -PI < ang <= PI

  while (ang <= -PI)
  {
    ang += 2*PI;
  }
  while (ang > PI)
  {
    ang -= 2*PI;
  }


  nxtDisplayStringAt(10, 50, "C");


  //TODO: if(abs(angle-ang) > 180) ang = -ang;

   //nxtDisplayStringAt(20, 20, "%f", ang);
  //if (ang < 0)
    //ang += PI;


  Turn(ang);

  nxtDisplayStringAt(10, 50, "D");

  dist = sqrt(dx*dx + dy*dy);
  if (dist > 20)
  {
    Forward(20);
    navigateToWaypointAux(num, wx, wy);
  }
  else
  {
    Forward(dist);
  }

  nxtDisplayStringAt(10, 50, "E");

  // If we think we are not yet at the waypoint reevaluate and try again
  /*
  if (x != wx && y != wy)
  {
    nxtDisplayStringAt(10, 10, "3");
    navigateToWaypointAux(wx, wy);
  }
  */
  nxtDisplayStringAt(10, 10, "WAYPOINT %d REACHED", num);
  wait1Msec(500);
}

void runPathTest()
{
  navigateToWaypoint(2, 180, 30);
  navigateToWaypoint(3, 180, 54);
  navigateToWaypoint(4, 126, 54);
  navigateToWaypoint(5, 126, 168);
  navigateToWaypoint(6, 126, 126);
  navigateToWaypoint(7, 30,  54);
  navigateToWaypoint(8, 84,  54);
  navigateToWaypoint(1, 84,  30);
}

task main()
{
  initParticles();
  runPathTest();
  wait1Msec(10000);
}
